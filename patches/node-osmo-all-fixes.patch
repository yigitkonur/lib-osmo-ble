From 9fd26083b1ebb353806271197c0db5fb7fc43d79 Mon Sep 17 00:00:00 2001
From: Lars Kappert <9989650+yigitkonur@users.noreply.github.com>
Date: Sun, 8 Feb 2026 05:15:42 -0800
Subject: [PATCH] Add dji-osmo CLI + fix 7 BLE protocol bugs for Osmo Pocket 3
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

CLI Commands:
- dji-osmo scan          â€” Discover nearby DJI Osmo devices
- dji-osmo stream        â€” Full BLEâ†’WiFiâ†’RTMP livestreaming
- dji-osmo pair          â€” Pair with device without streaming
- dji-osmo info          â€” Show device telemetry (battery, IMU, etc.)

Bug Fixes:
1. ByteBuf #byteOffset initialized to pool offset instead of 0
2. ByteBuf.from() missing byteLength in DataView constructor
3. ByteBuf getUint24() raw array access without pool offset
4. Message ID byte order: LEâ†’BE (matching wire format)
5. DUML writes to fff3â†’fff5 (writeWithoutResponse) â­
6. writeMessage() not async â€” fire-and-forget BLE writes
7. manufacturerData guard blocks Osmo Pocket 3 discovery

Additional:
- PROTOCOL.md with complete DUML-over-BLE specification
- --verbose flag for debug output
- Battery percentage decoding in info command
- Clean error handling and colored output
- Installable as global CLI via pnpm link
---
 PROTOCOL.md                   | 300 ++++++++++++++++++++
 examples/connect-to-device.js |   2 +-
 package.json                  |   5 +-
 src/bytebuf.ts                |  21 +-
 src/cli.mjs                   | 515 ++++++++++++++++++++++++++++++++++
 src/device.ts                 | 461 +++++++++++++++++++++---------
 src/message.ts                |  15 +-
 7 files changed, 1158 insertions(+), 161 deletions(-)
 create mode 100644 PROTOCOL.md
 create mode 100644 src/cli.mjs

diff --git a/PROTOCOL.md b/PROTOCOL.md
new file mode 100644
index 0000000..71a34aa
--- /dev/null
+++ b/PROTOCOL.md
@@ -0,0 +1,300 @@
+# DJI Osmo BLE Protocol Reference
+
+> **Verified on**: DJI Osmo Pocket 3 (model 3), firmware via BLE from macOS using `@stoprocent/noble`
+> **Last updated**: February 2026
+
+## Summary of Critical Findings
+
+This document describes the DUML-over-BLE protocol used by DJI Osmo cameras, discovered through reverse engineering the DJI Mimo app's BLE traffic (via [xaionaro/reverse-engineering-dji](https://github.com/xaionaro/reverse-engineering-dji)) and extensive trial-and-error debugging.
+
+### Key Breakthroughs
+
+1. **BLE Write Characteristic**: DUML commands must be written to **fff5** (`writeWithoutResponse`), NOT fff3. This was the single most critical discovery â€” writing to fff3 causes the device to silently ignore all commands.
+2. **ByteBuf Node.js Buffer Pool Bug**: Node.js Buffers share a pooled 8KB ArrayBuffer. Three separate bugs in `ByteBuf` caused all DUML message parsing to fail.
+3. **Message ID Byte Order**: Message IDs are Big Endian on the wire, not Little Endian.
+4. **manufacturerData Not Required**: The Osmo Pocket 3 does not include `manufacturerData` in its BLE advertisement â€” the discovery filter must not require it.
+
+---
+
+## BLE Characteristic Map
+
+| UUID | Name | Properties | Purpose |
+|------|------|-----------|---------|
+| **fff3** | â€” | read, write, notify, indicate | Unknown/unused for DUML (do NOT write DUML here) |
+| **fff4** | PairingRequestor | read, write, notify, indicate | Write `[0x01, 0x00]` to trigger pairing; receives DUML notifications |
+| **fff5** | Sender | read, writeWithoutResponse, notify, indicate | **Write DUML commands here** (writeWithoutResponse); also receives notifications |
+
+> **CRITICAL**: On the Osmo Pocket 3, ALL DUML telemetry and response messages arrive on **fff4** notifications. fff5 receives no notification data despite being subscribed. This may differ on other DJI devices.
+
+---
+
+## DUML Message Wire Format
+
+```
+[0x55] [len_lo] [ver<<2 | len_hi] [crc8] [target:2B LE] [id:2B BE] [type:3B] [payload:N] [crc16:2B LE]
+```
+
+| Field | Bytes | Encoding | Description |
+|-------|-------|----------|-------------|
+| Magic | 1 | â€” | Always `0x55` |
+| Length | 2 | 10-bit LE | `byte[1] | ((byte[2] & 0x03) << 8)`. Total message length including CRC16 = 13 + payload_length |
+| Version | â€” | `byte[2] >> 2` | Typically `1` (raw byte = `0x04` when length < 256) |
+| CRC8 | 1 | â€” | CRC8 of bytes [0..2]. Poly=0x31, Init=0xEE, RefIn=true, RefOut=true |
+| Target | 2 | Little Endian | `sender | (receiver << 8)`. E.g., App(0x02)â†’WiFi(0x07) = 0x0702 â†’ wire `02 07` |
+| Message ID | 2 | **Big Endian** | Sequence counter. Device echoes same ID in response |
+| Type | 3 | Wire order: `[flags, cmdSet, cmdId]` | flags=byte[8], cmdSet=byte[9], cmdId=byte[10] |
+| Payload | N | â€” | Command-specific data |
+| CRC16 | 2 | Little Endian | CRC16 of bytes [0..end-2]. Poly=0x1021, Init=0x496C, RefIn=true, RefOut=true |
+
+### Type Field Encoding
+
+The 3-byte type field is read as a 24-bit LE integer in code, but stored on the wire as `[flags, cmdSet, cmdId]`:
+
+| Constant (LE uint24) | Wire bytes | Flags | CmdSet | CmdId |
+|----------------------|-----------|-------|--------|-------|
+| 0x450740 | `40 07 45` | 0x40 (request) | 0x07 | 0x45 |
+| 0xC00745 | `C0 07 45` | 0xC0 (response) | 0x07 | 0x45 |
+
+- **Flags 0x40**: Request/command from app
+- **Flags 0xC0**: Response from device (or acknowledgment from app)
+- **Flags 0x00**: Unsolicited telemetry/notification
+
+### Response Matching
+
+Responses have the same `cmdSet` and `cmdId` as the request, with the response flag (0x80) set:
+- Request flags=0x40 â†’ Response flags=0xC0
+
+---
+
+## Complete Pairing + Streaming Flow (Verified)
+
+### Step 1: BLE Discovery & Connection
+```
+1. Scan for BLE device (localName contains "Osmo")
+2. Connect to peripheral
+3. Discover services â†’ find service fff0
+4. Discover characteristics fff3, fff4, fff5
+5. Subscribe to fff5 notifications (data channel)
+6. Subscribe to fff4 notifications (pairing + telemetry)
+7. Wait for first DUML message on fff4 (device is ready)
+```
+
+### Step 2: Pairing
+```
+1. Write [0x01, 0x00] to fff4 (triggers pairing mode on device)
+2. Wait 200ms
+3. Send SetPairingPIN via DUML on fff5:
+   - Type: 0x450740 (flags=0x40, cmdSet=0x07, cmdId=0x45)
+   - Target: 0x0702 (App â†’ WiFi subsystem)
+   - Payload: PackString(identifier) + PackString(PIN)
+     - identifier: "001749319286102" (15-char device identifier)
+     - PIN: "5160" (default, or read from device screen)
+4. Receive pairing_status response (0xC00745):
+   - payload[1] == 0x01: Already paired â†’ skip to Step 3
+   - payload[1] == 0x02: Pairing required â†’ wait for approval
+5. Receive pairing_pin_approved (0x400746): payload=0x01
+6. Proceed to streaming setup
+```
+
+### Step 3: Prepare to Livestream (Stage 1)
+```
+Send DUML on fff5:
+- Type: 0xE10240 (flags=0x40, cmdSet=0x02, cmdId=0xE1)
+- Target: 0x0802 (App â†’ Streaming subsystem)
+- Payload: [0x1A]
+Wait for response (0xC002E1): payload=0x00 means OK
+```
+
+### Step 4: Prepare to Livestream (Stage 2)
+```
+Send DUML on fff5:
+- Type: 0x8E0240 (flags=0x40, cmdSet=0x02, cmdId=0x8E)
+- Target: 0x0802
+- Payload: [0x00, 0x01, 0x1C, 0x00]
+Wait for response (0xC0028E)
+```
+
+### Step 5: Connect to WiFi
+```
+Send DUML on fff5:
+- Type: 0x470740 (flags=0x40, cmdSet=0x07, cmdId=0x47)
+- Target: 0x0702
+- Payload: PackString(SSID) + PackString(password)
+Wait for response (0xC00747): payload=0x0000 means connected OK
+```
+
+### Step 6: Configure Livestream
+```
+Send DUML on fff5:
+- Type: 0x780840 (flags=0x40, cmdSet=0x08, cmdId=0x78)
+- Target: 0x0802
+- Payload: [resolution, fps, bitrate config] + PackString(RTMP URL)
+```
+
+### Step 7: Start Livestream
+```
+Send DUML on fff5:
+- Type: 0x8E0240 (flags=0x40, cmdSet=0x02, cmdId=0x8E)
+- Target: 0x0802
+- Payload: [0x01, 0x01, 0x1A, 0x00, 0x01, 0x01]
+```
+
+---
+
+## Verified State Machine
+
+```
+idle(0) â†’ discovering(1) â†’ connecting(2) â†’ waitingForDevice(3) â†’ 
+checkingIfPaired(4) â†’ pairing(5) â†’ preparingStream(6) â†’ 
+preparingStream2(7) â†’ settingUpWifi(8) â†’ configuring(9) â†’ 
+startingStream(10) â†’ streaming(11)
+```
+
+### Verified Log Output (Successful Run)
+```
+State change 0 -> 1    (idle â†’ discovering)
+State change 1 -> 2    (â†’ connecting)
+State change 2 -> 3    (â†’ waitingForDevice)
+State change 3 -> 4    (â†’ checkingIfPaired: sent [0x01,0x00] + SetPairingPIN)
+Pairing response: flags=0xc0 payload=0002   â† "pairing required"
+State change 4 -> 5    (â†’ pairing)
+Pairing approved notification: payload=01   â† user approved on device
+State change 5 -> 6    (â†’ preparingStream)
+PrepareToLiveStream Stage1 response: payload=00   â† OK
+State change 6 -> 7    (â†’ preparingStream2)
+PrepareToLiveStream Stage2 response: payload=0000011c0009030900000000000020
+State change 7 -> 8    (â†’ settingUpWifi)
+WiFi setup response: payload=0000   â† connected to WiFi
+State change 8 -> 10   (â†’ startingStream, skipped configuring)
+State change 10 -> 11  (â†’ streaming âœ…)
+```
+
+---
+
+## Message Type Reference
+
+### Control Messages (App â†’ Device)
+
+| Name | Type (LE) | Wire bytes | CmdSet | CmdId | Target | Payload |
+|------|-----------|-----------|--------|-------|--------|---------|
+| SetPairingPIN | 0x450740 | `40 07 45` | 0x07 | 0x45 | 0x0702 | PackString(id) + PackString(pin) |
+| ConnectToWiFi | 0x470740 | `40 07 47` | 0x07 | 0x47 | 0x0702 | PackString(ssid) + PackString(pass) |
+| PrepareToLiveStream | 0xE10240 | `40 02 E1` | 0x02 | 0xE1 | 0x0802 | `[0x1A]` |
+| StartStopStreaming | 0x8E0240 | `40 02 8E` | 0x02 | 0x8E | 0x0802 | varies |
+| ConfigureLiveStream | 0x780840 | `40 08 78` | 0x08 | 0x78 | 0x0802 | config + URL |
+| ScanWiFi | 0xAB0740 | `40 07 AB` | 0x07 | 0xAB | 0x0702 | (empty) |
+
+### Response/Notification Messages (Device â†’ App)
+
+| Name | Type (LE) | CmdSet | CmdId | Flags | Meaning |
+|------|-----------|--------|-------|-------|---------|
+| PairingStatus | 0xC00745 | 0x07 | 0x45 | 0xC0 | payload[1]: 0x01=paired, 0x02=pairing required |
+| PairingPINApproved | 0x400746 | 0x07 | 0x46 | 0x40 | payload=0x01: PIN approved by user |
+| WiFiConnectResult | 0xC00747 | 0x07 | 0x47 | 0xC0 | payload=0x0000: success |
+| PrepareStreamResult | 0xC002E1 | 0x02 | 0xE1 | 0xC0 | payload=0x00: OK |
+| StreamResult | 0xC0028E | 0x02 | 0x8E | 0xC0 | varies |
+
+### Telemetry Messages (Unsolicited)
+
+| Name | Type (LE) | CmdSet | CmdId | Freq | Payload |
+|------|-----------|--------|-------|------|---------|
+| GimbalStatus | 0x050400 | 0x04 | 0x05 | ~20Hz | ~52B gyro/accel floats |
+| Keepalive | 0x270400 | 0x04 | 0x27 | ~10Hz | 5B |
+| CameraStatus | 0x800200 | 0x02 | 0x80 | ~10Hz | ~60B device state |
+| CameraVariant | 0xDC0200 | 0x02 | 0xDC | ~2Hz | ~22B |
+| GimbalAngle | 0x1C0400 | 0x04 | 0x1C | ~2Hz | 1B |
+| GeneralStatus | 0xF10000 | 0x00 | 0xF1 | ~1Hz | 4B |
+| GimbalSync | 0x380400 | 0x04 | 0x38 | ~1Hz | varies |
+| DeviceInfo | 0x810040 | 0x00 | 0x81 | ~1Hz | varies |
+| Battery | 0x020D00 | 0x0D | 0x02 | ~1Hz | varies |
+| DeviceVersion | 0x740040 | 0x00 | 0x74 | rare | varies |
+
+---
+
+## PackString Encoding
+
+Used for string fields (SSID, password, PIN, identifier):
+```
+[1B: string_length] [NB: string_bytes_utf8]
+```
+
+---
+
+## Bugs Fixed in node-osmo
+
+### 1. ByteBuf #byteOffset Initialization (CRITICAL)
+**File**: `src/bytebuf.ts:70`
+**Bug**: `#byteOffset` was initialized to `super.byteOffset` instead of `0`
+**Impact**: ALL reads at wrong positions due to Node.js Buffer pool offset
+**Fix**: Initialize to `0`
+
+### 2. ByteBuf.from() byteLength Propagation (CRITICAL)
+**File**: `src/bytebuf.ts:58-64`
+**Bug**: DataView constructor didn't receive `source.byteLength` for Buffer views
+**Impact**: DataView spanned entire 8KB Node.js Buffer pool instead of actual data
+**Fix**: Pass `source.byteLength` to DataView constructor
+
+### 3. ByteBuf getUint24() Offset (CRITICAL)
+**File**: `src/bytebuf.ts:325-334`
+**Bug**: `getUint24()` used `new Uint8Array(this.buffer)` without adding `super.byteOffset`
+**Impact**: ALL message types decoded incorrectly (type=1794 for everything)
+**Fix**: Add `super.byteOffset` when indexing into raw Uint8Array
+
+### 4. Message ID Byte Order
+**File**: `src/message.ts:55,97`
+**Bug**: Message ID encoded/decoded as Little Endian
+**Fix**: Changed to Big Endian (matching Wireshark captures and djictl)
+
+### 5. Write Characteristic (CRITICAL)
+**File**: `src/device.ts` â€” `writeValue()`
+**Bug**: DUML messages written to **fff3** characteristic
+**Fix**: Write to **fff5** using `writeWithoutResponse` (matching DJI Mimo app's actual behavior)
+
+### 6. writeMessage Not Awaited
+**File**: `src/device.ts:762`
+**Bug**: `writeMessage()` was not async, didn't await the BLE write
+**Fix**: Made async, all callers now await
+
+### 7. manufacturerData Guard
+**File**: `src/device.ts:235-238`
+**Bug**: `onDiscover()` required `manufacturerData` in BLE advertisement
+**Fix**: Removed guard â€” Osmo Pocket 3 doesn't include manufacturer data
+
+---
+
+## Tools
+
+### Build & Run
+```bash
+npx tsc                    # Build TypeScript
+node examples/connect-to-device.js <deviceId> <model> <ssid> <password> <rtmpUrl>
+```
+
+### BLE Utilities
+```bash
+# Reset macOS Bluetooth (if device stops advertising)
+blueutil --power 0 && sleep 2 && blueutil --power 1
+
+# Scan for DJI devices
+node --input-type=module -e "
+import noble from '@stoprocent/noble';
+noble.on('stateChange', (s) => { if (s === 'poweredOn') noble.startScanningAsync([], true); });
+noble.on('discover', (p) => {
+  if (p.advertisement?.localName?.includes('Osmo'))
+    console.log(p.advertisement.localName, p.id, 'RSSI:', p.rssi);
+});
+"
+```
+
+### Message Sniffer
+```bash
+npx tsx tools/message-sniffer.ts <device-id> <model>
+```
+
+---
+
+## References
+
+- [xaionaro/reverse-engineering-dji](https://github.com/xaionaro/reverse-engineering-dji) â€” Wireshark captures and dissector for DJI Mimo BLE protocol
+- Wireshark dissector: `dji-ble-message.c` in above repo â€” defines message type constants
+- djictl (Go implementation) â€” reference for pairing flow and message construction
diff --git a/examples/connect-to-device.js b/examples/connect-to-device.js
index c15f06d..74c0ab2 100644
--- a/examples/connect-to-device.js
+++ b/examples/connect-to-device.js
@@ -16,7 +16,7 @@ if (process.argv.length < 6) {
 }
 
 const deviceId = process.argv[2];
-const deviceModel = DjiDeviceModel.osmoAction4; // process.argv[3];
+const deviceModel = DjiDeviceModel.osmoPocket3; // process.argv[3];
 const wiFiName = process.argv[4];
 const wiFiPassword = process.argv[5];
 const rtmpUrl = process.argv[6];
diff --git a/package.json b/package.json
index dd221de..6cb6b9f 100644
--- a/package.json
+++ b/package.json
@@ -9,6 +9,9 @@
   "engines": {
     "node": ">= 20.9"
   },
+  "bin": {
+    "dji-osmo": "./dist/cli.mjs"
+  },
   "files": [
     "dist",
     "README.md"
@@ -50,7 +53,7 @@
     "tslib": "~2.6.3"
   },
   "volta": {
-    "node": "20.15.1",
+    "node": "18.20.8",
     "pnpm": "9.5.0"
   },
   "packageManager": "pnpm@9.5.0"
diff --git a/src/bytebuf.ts b/src/bytebuf.ts
index ef59ad3..d57c987 100644
--- a/src/bytebuf.ts
+++ b/src/bytebuf.ts
@@ -55,19 +55,19 @@ class ByteBuf extends DataView {
       byteOffset = source.byteOffset + (byteOffset || 0);
     }
 
-    return byteLength === undefined
+    const len = byteLength === undefined
+      ? (ArrayBuffer.isView(source) ? source.byteLength : undefined)
+      : Math.min(source.byteLength, byteLength);
+
+    return len === undefined
       ? new ByteBuf(buffer, byteOffset)
-      : new ByteBuf(
-          buffer,
-          byteOffset,
-          Math.min(source.byteLength, byteLength),
-        );
+      : new ByteBuf(buffer, byteOffset, len);
   }
 
   /**
    * The byte offset.
    */
-  #byteOffset: number = super.byteOffset;
+  #byteOffset: number = 0;
 
   /**
    * The byte offset.
@@ -325,10 +325,11 @@ class ByteBuf extends DataView {
   getUint24(byteOffset: number, littleEndian?: boolean): number {
     const buffer = new Uint8Array(this.buffer);
     const order = littleEndian ? littleEndian24 : bigEndian24;
+    const base = super.byteOffset + byteOffset;
 
-    const b0 = buffer[byteOffset + order[0]];
-    const b1 = buffer[byteOffset + order[1]] << 0x8;
-    const b2 = buffer[byteOffset + order[2]] << 0x10;
+    const b0 = buffer[base + order[0]];
+    const b1 = buffer[base + order[1]] << 0x8;
+    const b2 = buffer[base + order[2]] << 0x10;
 
     return b0 | b1 | b2;
   }
diff --git a/src/cli.mjs b/src/cli.mjs
new file mode 100644
index 0000000..f7c6baa
--- /dev/null
+++ b/src/cli.mjs
@@ -0,0 +1,515 @@
+#!/usr/bin/env node
+
+/**
+ * DJI Osmo CLI â€” Control DJI Osmo cameras via BLE from the command line.
+ *
+ * Commands:
+ *   scan              Scan for nearby DJI Osmo devices
+ *   stream            Start RTMP livestreaming
+ *   pair              Pair with a device (without streaming)
+ *   info              Connect and show device telemetry
+ */
+
+import noble from '@stoprocent/noble/with-custom-binding.js';
+import {
+  DjiDevice,
+  djiDeviceBitrates,
+  DjiDeviceImageStabilization,
+  DjiDeviceModel,
+  DjiDeviceResolution,
+} from '../dist/index.js';
+
+// Suppress library debug logs by default (re-enable with --verbose)
+const origDebug = console.debug;
+const origInfo = console.info;
+let verbose = process.argv.includes('--verbose') || process.argv.includes('-v');
+console.debug = (...args) => { if (verbose) origDebug(...args); };
+// Suppress "dji-device:" and "dji-scanner:" prefixed info logs
+const _origConsoleInfo = console.info;
+console.info = (...args) => {
+  const first = String(args[0] || '');
+  if (!verbose && (first.startsWith('dji-device:') || first.startsWith('dji-scanner:'))) return;
+  _origConsoleInfo(...args);
+};
+// Suppress "Powered on" and "dj-device:" logs from console.log
+const _origConsoleLog = console.log;
+console.log = (...args) => {
+  const first = String(args[0] || '');
+  if (!verbose && (first === 'Powered on' || first.startsWith('dj-device:'))) return;
+  _origConsoleLog(...args);
+};
+
+const HELP = `
+  dji-osmo â€” Control DJI Osmo cameras via Bluetooth
+
+  Usage:
+    dji-osmo scan [--timeout <seconds>]
+    dji-osmo stream <device-id> --ssid <wifi> --password <pass> --rtmp <url> [options]
+    dji-osmo pair <device-id> [--pin <code>]
+    dji-osmo info <device-id> [--duration <seconds>]
+
+  Commands:
+    scan        Scan for nearby DJI Osmo devices
+    stream      Start RTMP livestreaming via BLE â†’ WiFi â†’ RTMP
+    pair        Pair with a device (without streaming)
+    info        Connect and show live device telemetry
+
+  Stream Options:
+    --ssid, -s          WiFi network name (required)
+    --password, -p      WiFi password (required)
+    --rtmp, -r          RTMP URL (required)
+    --resolution        Video resolution: 480p, 720p, 1080p (default: 1080p)
+    --fps               Frame rate: 25, 30 (default: 30)
+    --bitrate           Bitrate in kbps (default: 6000)
+    --stabilization     Off, RockSteady, RockSteady+, HorizonBalancing, HorizonSteady
+    --pin               Pairing PIN code (default: 5160)
+    --model, -m         Device model: pocket3, action3, action4, action5pro (default: pocket3)
+
+  Scan Options:
+    --timeout, -t       Scan duration in seconds (default: 10)
+
+  Global Options:
+    --verbose, -v       Show detailed BLE debug output
+
+  Info Options:
+    --duration, -d      How long to collect telemetry in seconds (default: 15)
+    --model, -m         Device model (default: pocket3)
+
+  Pair Options:
+    --pin               Pairing PIN code (default: 5160)
+    --model, -m         Device model (default: pocket3)
+
+  Examples:
+    dji-osmo scan
+    dji-osmo stream abc123 -s MyWiFi -p secret --rtmp rtmp://server/live/key
+    dji-osmo pair abc123
+    dji-osmo info abc123
+
+  Environment:
+    Requires macOS with Bluetooth enabled.
+    Install blueutil for BLE reset: brew install blueutil
+`;
+
+// â”€â”€â”€ Argument Parser â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+
+function parseArgs(argv) {
+  const args = argv.slice(2);
+  const command = args[0];
+  const positional = [];
+  const flags = {};
+
+  for (let i = 1; i < args.length; i++) {
+    const arg = args[i];
+    if (arg.startsWith('--')) {
+      const key = arg.slice(2);
+      const next = args[i + 1];
+      if (next && !next.startsWith('-')) {
+        flags[key] = next;
+        i++;
+      } else {
+        flags[key] = true;
+      }
+    } else if (arg.startsWith('-') && arg.length === 2) {
+      const shortMap = { s: 'ssid', p: 'password', r: 'rtmp', t: 'timeout', m: 'model', d: 'duration' };
+      const key = shortMap[arg[1]] || arg[1];
+      const next = args[i + 1];
+      if (next && !next.startsWith('-')) {
+        flags[key] = next;
+        i++;
+      } else {
+        flags[key] = true;
+      }
+    } else {
+      positional.push(arg);
+    }
+  }
+
+  return { command, positional, flags };
+}
+
+function resolveModel(name) {
+  const map = {
+    pocket3: DjiDeviceModel.osmoPocket3,
+    action3: DjiDeviceModel.osmoAction3,
+    action4: DjiDeviceModel.osmoAction4,
+    action5pro: DjiDeviceModel.osmoAction5Pro,
+  };
+  return map[name?.toLowerCase()] ?? DjiDeviceModel.osmoPocket3;
+}
+
+function resolveResolution(name) {
+  const map = { '480p': DjiDeviceResolution.r480p, '720p': DjiDeviceResolution.r720p, '1080p': DjiDeviceResolution.r1080p };
+  return map[name] ?? DjiDeviceResolution.r1080p;
+}
+
+function resolveStabilization(name) {
+  const map = {
+    off: DjiDeviceImageStabilization.Off,
+    rocksteady: DjiDeviceImageStabilization.RockSteady,
+    'rocksteady+': DjiDeviceImageStabilization.RockSteadyPlus,
+    horizonbalancing: DjiDeviceImageStabilization.HorizonBalancing,
+    horizonsteady: DjiDeviceImageStabilization.HorizonSteady,
+  };
+  return map[name?.toLowerCase()] ?? DjiDeviceImageStabilization.RockSteadyPlus;
+}
+
+function die(msg) {
+  console.error(`\x1b[31mâœ—\x1b[0m ${msg}`);
+  process.exit(1);
+}
+
+function info(msg) {
+  console.log(`\x1b[36mâ„¹\x1b[0m ${msg}`);
+}
+
+function success(msg) {
+  console.log(`\x1b[32mâœ“\x1b[0m ${msg}`);
+}
+
+function warn(msg) {
+  console.log(`\x1b[33mâš \x1b[0m ${msg}`);
+}
+
+// â”€â”€â”€ Commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+
+async function cmdScan(flags) {
+  const timeout = parseInt(flags.timeout || '10') * 1000;
+  const found = new Map();
+
+  info(`Scanning for DJI Osmo devices (${timeout / 1000}s)...`);
+  console.log();
+
+  const n = noble({ extended: false });
+
+  n.on('stateChange', (state) => {
+    if (state === 'poweredOn') {
+      n.startScanningAsync([], true);
+    } else {
+      die(`Bluetooth adapter state: ${state}. Is Bluetooth enabled?`);
+    }
+  });
+
+  n.on('discover', (peripheral) => {
+    const name = peripheral.advertisement?.localName || '';
+    if (!name.includes('Osmo') && !name.includes('DJI') && !name.includes('Pocket') && !name.includes('Action')) return;
+    if (found.has(peripheral.id)) return;
+
+    const mfr = peripheral.advertisement?.manufacturerData;
+    found.set(peripheral.id, true);
+
+    console.log(`  \x1b[1m${name}\x1b[0m`);
+    console.log(`    ID:    ${peripheral.id}`);
+    console.log(`    RSSI:  ${peripheral.rssi} dBm`);
+    if (mfr) console.log(`    Mfr:   ${mfr.toString('hex')}`);
+    console.log();
+  });
+
+  await new Promise((resolve) => setTimeout(resolve, timeout));
+  n.stopScanning();
+
+  if (found.size === 0) {
+    warn('No DJI devices found. Make sure your camera is powered on and nearby.');
+  } else {
+    success(`Found ${found.size} device(s). Use the ID with other commands.`);
+  }
+
+  process.exit(0);
+}
+
+async function cmdStream(positional, flags) {
+  const deviceId = positional[0];
+  if (!deviceId) die('Missing device ID. Run "dji-osmo scan" to find your device.');
+  if (!flags.ssid) die('Missing --ssid. Specify the WiFi network name.');
+  if (!flags.password) die('Missing --password. Specify the WiFi password.');
+  if (!flags.rtmp) die('Missing --rtmp. Specify the RTMP URL.');
+
+  const model = resolveModel(flags.model);
+  const resolution = resolveResolution(flags.resolution);
+  const fps = parseInt(flags.fps || '30');
+  const bitrate = parseInt(flags.bitrate || '6000') * 1000;
+  const stabilization = resolveStabilization(flags.stabilization);
+  const pin = flags.pin || '5160';
+
+  info(`Connecting to device ${deviceId}...`);
+  info(`WiFi: ${flags.ssid} | RTMP: ${flags.rtmp}`);
+  info(`Resolution: ${resolution} | FPS: ${fps} | Bitrate: ${bitrate / 1000}kbps | Stabilization: ${stabilization}`);
+  console.log();
+
+  const device = new DjiDevice(deviceId, model);
+  device.setPairPinCode(pin);
+
+  // Track state changes for user-friendly output
+  const stateNames = {
+    0: 'idle', 1: 'discovering', 2: 'connecting', 3: 'waiting for device',
+    4: 'checking pairing', 5: 'pairing', 6: 'preparing stream (1/2)',
+    7: 'preparing stream (2/2)', 8: 'connecting WiFi', 9: 'configuring',
+    10: 'starting stream', 11: 'streaming', 12: 'stopping',
+  };
+
+  const origSetState = device.setState?.bind(device);
+  let lastState = -1;
+
+  // Monitor state by polling (since setState is private)
+  const stateMonitor = setInterval(() => {
+    const s = device.getState();
+    if (s !== lastState) {
+      lastState = s;
+      const name = stateNames[s] || `unknown(${s})`;
+      if (s === 11) {
+        console.log();
+        success(`ðŸŽ¥ STREAMING LIVE â†’ ${flags.rtmp}`);
+        console.log();
+        info('Press Ctrl+C to stop streaming.');
+      } else {
+        info(`State: ${name}`);
+      }
+    }
+  }, 200);
+
+  // Handle Ctrl+C gracefully
+  process.on('SIGINT', () => {
+    console.log();
+    info('Stopping stream...');
+    device.stopLiveStream();
+    clearInterval(stateMonitor);
+    setTimeout(() => {
+      success('Stream stopped. Goodbye!');
+      process.exit(0);
+    }, 3000);
+  });
+
+  try {
+    await device.startLiveStream(
+      flags.ssid,
+      flags.password,
+      flags.rtmp,
+      resolution,
+      fps,
+      bitrate,
+      stabilization,
+    );
+  } catch (err) {
+    clearInterval(stateMonitor);
+    die(`Stream failed: ${err.message}`);
+  }
+}
+
+async function cmdPair(positional, flags) {
+  const deviceId = positional[0];
+  if (!deviceId) die('Missing device ID. Run "dji-osmo scan" to find your device.');
+
+  const model = resolveModel(flags.model);
+  const pin = flags.pin || '5160';
+
+  info(`Pairing with device ${deviceId} (PIN: ${pin})...`);
+  console.log();
+
+  const device = new DjiDevice(deviceId, model);
+  device.setPairPinCode(pin);
+
+  let paired = false;
+  let shownWaiting = false;
+  const stateMonitor = setInterval(() => {
+    const s = device.getState();
+    if (s === 5 && !shownWaiting) {
+      shownWaiting = true;
+      info('Waiting for pairing approval on device screen...');
+    }
+    if (s >= 4 && !paired) {
+      // State 4 with payload=0001 means already paired (goes to 6 quickly)
+      // State 5 means pairing in progress
+      // State 6+ means pairing succeeded
+      if (s >= 6) {
+        paired = true;
+        success('Device paired successfully!');
+        clearInterval(stateMonitor);
+        // Exit immediately â€” don't call stopLiveStream with dummy config
+        process.exit(0);
+      }
+    }
+  }, 200);
+
+  // Start the flow but we only care about pairing
+  // Use a dummy RTMP URL â€” we'll stop before WiFi connects
+  try {
+    await device.startLiveStream(
+      'dummy-ssid',
+      'dummy-pass',
+      'rtmp://localhost/dummy',
+      DjiDeviceResolution.r1080p,
+      30,
+      2000000,
+      DjiDeviceImageStabilization.Off,
+    );
+  } catch {
+    // Expected to fail after pairing since dummy WiFi won't work
+  }
+
+  // Timeout
+  setTimeout(() => {
+    if (!paired) {
+      clearInterval(stateMonitor);
+      die('Pairing timed out. Make sure the camera screen is visible and approve the pairing request.');
+    }
+  }, 60000);
+}
+
+async function cmdInfo(positional, flags) {
+  const deviceId = positional[0];
+  if (!deviceId) die('Missing device ID. Run "dji-osmo scan" to find your device.');
+
+  const model = resolveModel(flags.model);
+  const duration = parseInt(flags.duration || '15') * 1000;
+
+  info(`Connecting to ${deviceId} to collect telemetry (${duration / 1000}s)...`);
+  console.log();
+
+  // Use noble directly for a lightweight connection
+  const n = noble({ extended: false });
+  let peripheral;
+
+  await new Promise((resolve, reject) => {
+    n.on('stateChange', (state) => {
+      if (state === 'poweredOn') n.startScanningAsync([], false);
+      else reject(new Error(`Bluetooth state: ${state}`));
+    });
+    n.on('discover', async (p) => {
+      if (p.id !== deviceId) return;
+      n.stopScanning();
+      peripheral = p;
+      resolve(undefined);
+    });
+    setTimeout(() => reject(new Error('Device not found within 10 seconds')), 10000);
+  });
+
+  const name = peripheral.advertisement?.localName || 'Unknown';
+  success(`Found: ${name} (RSSI: ${peripheral.rssi} dBm)`);
+  console.log();
+
+  await peripheral.connectAsync();
+  success('Connected');
+
+  const { characteristics } = await peripheral.discoverSomeServicesAndCharacteristicsAsync(
+    ['fff0'], ['fff4', 'fff5']
+  );
+
+  const fff4 = characteristics.find(c => c.uuid === 'fff4');
+  const fff5 = characteristics.find(c => c.uuid === 'fff5');
+
+  if (!fff4 || !fff5) die('Required BLE characteristics not found.');
+
+  // Message stats
+  const msgStats = {};
+  let msgCount = 0;
+  let receiveBuffer = Buffer.alloc(0);
+
+  const parseMessages = (data) => {
+    receiveBuffer = Buffer.concat([receiveBuffer, data]);
+    while (receiveBuffer.length >= 4) {
+      if (receiveBuffer[0] !== 0x55) {
+        receiveBuffer = receiveBuffer.subarray(1);
+        continue;
+      }
+      const len = receiveBuffer[1] | ((receiveBuffer[2] & 0x03) << 8);
+      if (len > receiveBuffer.length) break;
+      if (len < 13) { receiveBuffer = receiveBuffer.subarray(1); continue; }
+
+      const msg = receiveBuffer.subarray(0, len);
+      receiveBuffer = receiveBuffer.subarray(len);
+
+      const flags = msg[8];
+      const cmdSet = msg[9];
+      const cmdId = msg[10];
+      const payload = msg.subarray(11, len - 2);
+
+      const key = `0x${cmdSet.toString(16).padStart(2, '0')}:0x${cmdId.toString(16).padStart(2, '0')}`;
+      if (!msgStats[key]) msgStats[key] = { count: 0, cmdSet, cmdId, lastPayload: '', flags };
+      msgStats[key].count++;
+      msgStats[key].lastPayload = payload.toString('hex').slice(0, 40);
+      msgCount++;
+    }
+  };
+
+  await fff5.subscribeAsync();
+  fff5.on('data', parseMessages);
+  await fff4.subscribeAsync();
+  fff4.on('data', parseMessages);
+
+  info(`Collecting telemetry for ${duration / 1000}s...`);
+  console.log();
+
+  await new Promise(resolve => setTimeout(resolve, duration));
+
+  // Display results
+  const battery = Object.entries(msgStats).find(([k]) => k === '0x0d:0x02');
+  let batteryPct = null;
+  if (battery) {
+    const bPayload = Buffer.from(battery[1].lastPayload, 'hex');
+    if (bPayload.length >= 2) batteryPct = bPayload[1];
+  }
+
+  console.log('\x1b[1m  Device Information\x1b[0m');
+  console.log(`  Name:     ${name}`);
+  console.log(`  ID:       ${deviceId}`);
+  console.log(`  RSSI:     ${peripheral.rssi} dBm`);
+  if (batteryPct !== null) console.log(`  Battery:  ${batteryPct}%`);
+  console.log();
+
+  console.log('\x1b[1m  Message Summary\x1b[0m');
+  console.log(`  Total messages received: ${msgCount}`);
+  console.log();
+
+  console.log('  \x1b[4mCmdSet  CmdId   Count   Description\x1b[0m');
+
+  const descriptions = {
+    '0x04:0x05': 'Gimbal/IMU status',
+    '0x04:0x27': 'Keepalive',
+    '0x02:0x80': 'Camera status',
+    '0x02:0xdc': 'Camera variant',
+    '0x04:0x1c': 'Gimbal angle',
+    '0x00:0xf1': 'General status',
+    '0x04:0x38': 'Gimbal sync',
+    '0x00:0x81': 'Device info',
+    '0x0d:0x02': 'Battery',
+    '0x00:0x74': 'Device version',
+    '0x04:0x09': 'Sensor data',
+    '0x02:0x27': 'Recording status',
+  };
+
+  const sorted = Object.entries(msgStats).sort((a, b) => b[1].count - a[1].count);
+  for (const [key, val] of sorted) {
+    const desc = descriptions[key] || '';
+    console.log(`  ${key.split(':')[0].padEnd(8)}${key.split(':')[1].padEnd(8)}${String(val.count).padEnd(8)}${desc}`);
+  }
+  console.log();
+
+  await peripheral.disconnectAsync();
+  success('Disconnected. Goodbye!');
+  process.exit(0);
+}
+
+// â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+
+const { command, positional, flags } = parseArgs(process.argv);
+
+if (!command || flags.help || command === 'help' || command === '--help' || command === '-h') {
+  console.log(HELP);
+  process.exit(0);
+}
+
+switch (command) {
+  case 'scan':
+    await cmdScan(flags);
+    break;
+  case 'stream':
+    await cmdStream(positional, flags);
+    break;
+  case 'pair':
+    await cmdPair(positional, flags);
+    break;
+  case 'info':
+    await cmdInfo(positional, flags);
+    break;
+  default:
+    die(`Unknown command: ${command}. Run "dji-osmo --help" for usage.`);
+}
diff --git a/src/device.ts b/src/device.ts
index 8a147f3..267eb46 100644
--- a/src/device.ts
+++ b/src/device.ts
@@ -22,9 +22,11 @@ import {
 const pairTransactionId = 0x8092;
 const stopStreamingTransactionId = 0xeac8;
 const preparingToLivestreamTransactionId = 0x8c12;
+const preparingToLivestreamStage2TransactionId = 0x8c13;
 const setupWifiTransactionId = 0x8c19;
 const startStreamingTransactionId = 0x8c2c;
 const configureTransactionId = 0x8c2d;
+const confirmStartStreamingTransactionId = 0x8c2e;
 
 const pairTarget = 0x0702;
 const stopStreamingTarget = 0x0802;
@@ -36,6 +38,7 @@ const startStreamingTarget = 0x0802;
 const pairType = 0x450740;
 const stopStreamingType = 0x8e0240;
 const preparingToLivestreamType = 0xe10240;
+const startStopStreamingType = 0x8e0240;
 const setupWifiType = 0x470740;
 const configureType = 0x8e0240;
 const startStreamingType = 0x780840;
@@ -49,10 +52,11 @@ enum DjiDeviceState {
   idle,
   discovering,
   connecting,
+  waitingForDevice,  // waiting for first DUML message after subscribe
   checkingIfPaired,
   pairing,
-  cleaningUp,
   preparingStream,
+  preparingStream2,
   settingUpWifi,
   configuring,
   startingStream,
@@ -72,10 +76,12 @@ export class DjiDevice {
   private imageStabilization?: DjiDeviceImageStabilization =
     DjiDeviceImageStabilization.RockSteadyPlus;
   private deviceId?: string;
-  private pairPinCode?: string = 'love';
+  private pairPinCode?: string = '5160';
   private noble?: typeof noble;
   private cameraPeripheral?: Peripheral;
   private fff3Characteristic?: Characteristic;
+  private fff4Characteristic?: Characteristic;
+  private fff5Characteristic?: Characteristic;
   private state: DjiDeviceState = DjiDeviceState.idle;
   private startStreamingTimer?: NodeJS.Timeout;
   private stopStreamingTimer?: NodeJS.Timeout;
@@ -86,6 +92,8 @@ export class DjiDevice {
     state: DjiDeviceState,
   ) => void;
   private batteryPercentage?: number;
+  private receiveBufferFff4: Buffer = Buffer.alloc(0);
+  private receiveBufferFff5: Buffer = Buffer.alloc(0);
 
   constructor(deviceId: string, model: DjiDeviceModel) {
     this.deviceId = deviceId;
@@ -141,7 +149,11 @@ export class DjiDevice {
     }
     this.cameraPeripheral = undefined;
     this.fff3Characteristic = undefined;
+    this.fff4Characteristic = undefined;
+    this.fff5Characteristic = undefined;
     this.batteryPercentage = undefined;
+    this.receiveBufferFff4 = Buffer.alloc(0);
+    this.receiveBufferFff5 = Buffer.alloc(0);
     this.setState(DjiDeviceState.idle);
   }
 
@@ -222,15 +234,13 @@ export class DjiDevice {
     if (this.state !== DjiDeviceState.discovering) {
       return;
     }
-    const manufacturerData = peripheral.advertisement.manufacturerData;
-    if (!manufacturerData) {
-      return;
-    }
+    // Change state immediately to prevent duplicate onDiscover calls from proceeding
+    this.setState(DjiDeviceState.connecting);
     this.noble?.stopScanning();
     this.cameraPeripheral = peripheral;
 
     if (peripheral.state !== 'connected') {
-      console.info('dj-device: Try to connect asynchronously');
+      console.info('dji-device: Try to connect asynchronously');
       await peripheral
         .connectAsync()
         .then(() => {
@@ -250,80 +260,56 @@ export class DjiDevice {
       return;
     }
 
-    peripheral.discoverServices([], this.onDiscoverServices.bind(this));
+    peripheral.discoverServices(
+      [],
+      (err: string, services: Service[]) => {
+        this.onDiscoverServices(err, services);
+      },
+    );
     this.startStartStreamingTimer();
-    this.setState(DjiDeviceState.connecting);
   }
 
-  private onDiscoverServices(error: Error | null, services: Service[]): void {
+  private async onDiscoverServices(
+    error: string | null,
+    services: Service[],
+  ): Promise<void> {
     if (error) {
       console.error('dji-device: Service discovery error', error);
       return;
     }
-    services.forEach((service) => {
+    // Only process the DJI-specific service (fff0), skip standard BLE services
+    // Processing multiple services in parallel causes CoreBluetooth crashes on macOS
+    for (const service of services) {
       console.info(`dji-device: Discovered service ${service.uuid}`);
-      service.discoverCharacteristics(
-        [],
-        this.onDiscoverCharacteristics.bind(this),
-      );
-    });
-  }
-
-  private onDiscoverCharacteristics(
-    error: Error | null,
-    characteristics: Characteristic[],
-  ): void {
-    if (error) {
-      console.error('dji-device: Characteristic discovery error', error);
-      return;
-    }
-    characteristics.forEach((characteristic) => {
-      if (!allowedCharacteristics.includes(characteristic.uuid)) {
+      if (service.uuid !== fff0Id) {
         console.debug(
-          `dji-device: Ignoring characteristic ${characteristic.uuid}`,
+          `dji-device: Skipping non-DJI service ${service.uuid}`,
         );
-        return;
+        continue;
       }
-      console.info(
-        `dji-device: Subscribing to characteristic ${characteristic.uuid}`,
-      );
-      if (characteristic.uuid === fff3Id) {
-        this.fff3Characteristic = characteristic;
+      await this.discoverAndSubscribeCharacteristics(service);
+    }
+
+    // After characteristics are discovered and subscribed, send pairing request
+    // by writing [0x01, 0x00] to fff4 (pairing requestor) â€” this triggers the device
+    // to enter pairing mode. Then send SetPairingPIN via DUML on fff3.
+    // This matches djictl's flow: SendPairingRequest â†’ SetPairingPIN
+    if (this.fff4Characteristic) {
+      console.info('dji-device: Sending pairing request [0x01,0x00] to fff4');
+      try {
+        await this.fff4Characteristic.writeAsync(
+          Buffer.from([0x01, 0x00]),
+          false,
+        );
+        console.info('dji-device: Pairing request sent, now sending PIN');
+      } catch (err) {
+        console.error('dji-device: Failed to write pairing request to fff4', err);
       }
-      characteristic
-        .subscribeAsync()
-        .then(async () => {
-          console.info(
-            'dji-device: Subscribed to characteristic',
-            characteristic.uuid,
-          );
-          characteristic.on('data', (data) => {
-            if (error) {
-              console.error('dji-device: Characteristic read error', error);
-              return;
-            }
-            this.onCharacteristicValueChanged(characteristic, data);
-          });
-          await characteristic.notifyAsync(true);
-          await characteristic.readAsync();
-        })
-        .catch((error) => {
-          if (error) {
-            console.error('dji-device: Characteristic subscribe error', error);
-          }
-        });
-    });
-  }
 
-  private onCharacteristicValueChanged(
-    characteristic: Characteristic,
-    value: Buffer,
-  ): void {
-    if (
-      this.state === DjiDeviceState.connecting &&
-      characteristic.uuid === fff4Id
-    ) {
-      console.info('dji-device: Attempting to pair');
+      // Small delay to let device process pairing request
+      await new Promise((r) => setTimeout(r, 200));
+
+      // Send SetPairingPIN via DUML on fff3
       const payload = new DjiPairMessagePayload(this.pairPinCode);
       const request = new DjiMessage(
         pairTarget,
@@ -331,42 +317,187 @@ export class DjiDevice {
         pairType,
         payload.encode(),
       );
-      this.writeMessage(request);
+      await this.writeMessage(request);
       this.setState(DjiDeviceState.checkingIfPaired);
-      return;
+    }
+  }
+
+  private async discoverAndSubscribeCharacteristics(
+    service: Service,
+  ): Promise<void> {
+    return new Promise<void>((resolve, reject) => {
+      service.discoverCharacteristics(
+        [],
+        async (error: string | null, characteristics: Characteristic[]) => {
+          if (error) {
+            console.error(
+              'dji-device: Characteristic discovery error',
+              error,
+            );
+            reject(error);
+            return;
+          }
+          // Serialize characteristic subscription to avoid CoreBluetooth crashes
+          // First pass: store references and subscribe to fff5 (DUML data channel)
+          for (const characteristic of characteristics) {
+            if (!allowedCharacteristics.includes(characteristic.uuid)) {
+              continue;
+            }
+            console.info(
+              `dji-device: Found characteristic ${characteristic.uuid}`,
+            );
+            if (characteristic.uuid === fff3Id) {
+              this.fff3Characteristic = characteristic;
+            }
+            if (characteristic.uuid === fff4Id) {
+              this.fff4Characteristic = characteristic;
+            }
+            if (characteristic.uuid === fff5Id) {
+              this.fff5Characteristic = characteristic;
+            }
+            // Subscribe to fff5 first (data channel) before fff4 (pairing trigger)
+            if (characteristic.uuid === fff5Id) {
+              try {
+                await characteristic.subscribeAsync();
+                console.info(
+                  'dji-device: Subscribed to characteristic',
+                  characteristic.uuid,
+                );
+                characteristic.on('data', (data: Buffer) => {
+                  this.onCharacteristicValueChanged(characteristic, data);
+                });
+                await new Promise((r) => setTimeout(r, 100));
+              } catch (subscribeError) {
+                console.error(
+                  'dji-device: Characteristic subscribe error',
+                  subscribeError,
+                );
+              }
+            }
+          }
+          // Second pass: subscribe to fff4 (pairing trigger) â€” this must happen
+          // after fff5 is ready so we can receive the pairing response
+          if (this.fff4Characteristic) {
+            try {
+              await this.fff4Characteristic.subscribeAsync();
+              console.info('dji-device: Subscribed to characteristic fff4');
+              this.fff4Characteristic.on('data', (data: Buffer) => {
+                this.onCharacteristicValueChanged(this.fff4Characteristic!, data);
+              });
+              await new Promise((r) => setTimeout(r, 100));
+            } catch (subscribeError) {
+              console.error(
+                'dji-device: fff4 subscribe error',
+                subscribeError,
+              );
+            }
+          }
+          resolve();
+        },
+      );
+    });
+  }
+
+  private onCharacteristicValueChanged(
+    characteristic: Characteristic,
+    value: Buffer,
+  ): void {
+    // fff4 serves dual purpose: pairing trigger (non-DUML) and DUML data channel
+    if (characteristic.uuid === fff4Id) {
+      if (this.state === DjiDeviceState.connecting) {
+        // First data on fff4 while connecting â€” device is ready
+        // Set state to waitingForDevice; pairing request will be sent after
+        // discoverAndSubscribeCharacteristics finishes (see the code after that call)
+        console.info('dji-device: Device responded on fff4, waiting for pairing request');
+        this.setState(DjiDeviceState.waitingForDevice);
+        return;
+      }
+      // After pairing trigger, fff4 sends DUML messages â€” fall through to process them
     }
 
     if (!value?.length) {
-      console.info('dji-device: Received empty message');
       return;
     }
 
-    let message;
-    try {
-      message = new DjiMessageWithData(value);
+    // Select per-characteristic receive buffer
+    const isFff4 = characteristic.uuid === fff4Id;
+    let buf = isFff4 ? this.receiveBufferFff4 : this.receiveBufferFff5;
+
+    // Buffer incoming data â€” BLE messages may arrive fragmented across multiple notifications
+    buf = Buffer.concat([buf, value]);
+
+    // Try to parse complete messages from the buffer
+    while (buf.length >= 13) {
+      // Check for DUML magic byte
+      if (buf[0] !== 0x55) {
+        // Skip bytes until we find the magic byte
+        const magicIdx = buf.indexOf(0x55);
+        if (magicIdx === -1) {
+          buf = Buffer.alloc(0);
+          break;
+        }
+        buf = buf.subarray(magicIdx);
+        continue;
+      }
+
+      // Read message length from header
+      const msgLength = buf[1] | ((buf[2] & 0x03) << 8);
+      if (msgLength < 13) {
+        // Invalid length, skip this byte
+        buf = buf.subarray(1);
+        continue;
+      }
+
+      if (buf.length < msgLength) {
+        // Incomplete message, wait for more data
+        break;
+      }
+
+      // Extract complete message
+      const messageData = Buffer.from(buf.subarray(0, msgLength));
+      buf = buf.subarray(msgLength);
+
+      let message: DjiMessageWithData;
+      try {
+        message = new DjiMessageWithData(messageData);
+      } catch (error) {
+        // Log only first byte and length for debugging, silently skip invalid data
+        if (messageData[0] === 0x55) {
+          console.debug(`dji-device: Parse failed for ${messageData.toString('hex').substring(0, 30)}... (${error})`);
+        }
+        continue;
+      }
+
       console.info(`dji-device: Received message ${message.format()}`);
-    } catch (error) {
-      console.error(
-        `dji-device: Error parsing message from characteristic ${characteristic.uuid}`,
-        error,
-      );
-      return;
+
+      this.processMessage(message);
     }
 
-    console.info(`dji-device: Got ${message.format()}`);
+    // Store updated buffer back
+    if (isFff4) {
+      this.receiveBufferFff4 = buf;
+    } else {
+      this.receiveBufferFff5 = buf;
+    }
+  }
+
+  private processMessage(message: DjiMessageWithData): void {
     switch (this.state) {
+      case DjiDeviceState.waitingForDevice:
+        // Ignore DUML messages while waiting â€” pairing will start after fff4 write
+        break;
       case DjiDeviceState.checkingIfPaired:
         this.processCheckingIfPaired(message);
         break;
       case DjiDeviceState.pairing:
-        this.processPairing();
-        break;
-      case DjiDeviceState.cleaningUp:
-        this.processCleaningUp(message);
+        this.processPairing(message);
         break;
       case DjiDeviceState.preparingStream:
         this.processPreparingStream(message);
         break;
+      case DjiDeviceState.preparingStream2:
+        this.processPreparingStream2(message);
+        break;
       case DjiDeviceState.settingUpWifi:
         this.processSettingUpWifi(message);
         break;
@@ -382,6 +513,8 @@ export class DjiDevice {
       case DjiDeviceState.stoppingStream:
         this.processStoppingStream(message);
         break;
+      case 0:
+        break;
       default:
         console.info(
           `dji-device: Received message in unexpected state '${this.state}'`,
@@ -389,9 +522,9 @@ export class DjiDevice {
     }
   }
 
-  private sendStopStream(): void {
+  private async sendStopStream(): Promise<void> {
     const payload = new DjiStopStreamingMessagePayload();
-    this.writeMessage(
+    await this.writeMessage(
       new DjiMessage(
         stopStreamingTarget,
         stopStreamingTransactionId,
@@ -401,28 +534,42 @@ export class DjiDevice {
     );
   }
 
-  private processCheckingIfPaired(response: DjiMessage): void {
-    if (response.id !== pairTransactionId) {
+  private async processCheckingIfPaired(response: DjiMessage): Promise<void> {
+    // Response to SetPairingPIN: cmdSet=0x07, cmdId=0x45 with response flag
+    const flags = response.type & 0xff;
+    const cmdSet = (response.type >> 8) & 0xff;
+    const cmdId = (response.type >> 16) & 0xff;
+    if (cmdSet !== 0x07 || cmdId !== 0x45) {
       return;
     }
-    if (response.payload.equals(Buffer.from([0, 1]))) {
-      this.processPairing();
+    console.info(`dji-device: Pairing response: flags=0x${flags.toString(16)} payload=${response.payload.toString('hex')}`);
+    if (response.payload.length >= 2 && response.payload[1] === 0x01) {
+      // Already paired â€” go directly to preparing stream
+      console.info('dji-device: Device is already paired, preparing stream');
+      this.sendPrepareToLivestreamStage1();
     } else {
+      // Not yet paired â€” wait for user to approve PIN on device
+      console.info('dji-device: Pairing required â€” approve PIN on device');
       this.setState(DjiDeviceState.pairing);
     }
   }
 
-  private processPairing(): void {
-    this.sendStopStream();
-    this.setState(DjiDeviceState.cleaningUp);
-  }
-
-  private processCleaningUp(response: DjiMessage): void {
-    if (response.id !== stopStreamingTransactionId) {
+  private async processPairing(response: DjiMessage): Promise<void> {
+    // Look for PairingPINApproved: cmdSet=0x07, cmdId=0x46
+    const cmdSet = (response.type >> 8) & 0xff;
+    const cmdId = (response.type >> 16) & 0xff;
+    if (cmdSet !== 0x07 || cmdId !== 0x46) {
       return;
     }
+    console.info(`dji-device: Pairing approved notification: payload=${response.payload.toString('hex')}`);
+    console.info('dji-device: Pairing approved, preparing stream');
+    this.sendPrepareToLivestreamStage1();
+  }
+
+  private async sendPrepareToLivestreamStage1(): Promise<void> {
+    console.info('dji-device: Sending PrepareToLiveStream Stage1');
     const payload = new DjiPreparingToLivestreamMessagePayload();
-    this.writeMessage(
+    await this.writeMessage(
       new DjiMessage(
         preparingToLivestreamTarget,
         preparingToLivestreamTransactionId,
@@ -433,19 +580,40 @@ export class DjiDevice {
     this.setState(DjiDeviceState.preparingStream);
   }
 
-  private processPreparingStream(response: DjiMessage): void {
-    if (
-      response.id !== preparingToLivestreamTransactionId ||
-      !this.wifiSsid ||
-      !this.wifiPassword
-    ) {
+  private async processPreparingStream(response: DjiMessage): Promise<void> {
+    // Accept response to PrepareToLiveStream (cmdSet=0x02, cmdId=0xE1) with response flag
+    if (!this.isResponseTo(response, preparingToLivestreamType)) {
       return;
     }
+    console.info(`dji-device: PrepareToLiveStream Stage1 response: payload=${response.payload.toString('hex')}`);
+    // Stage1 response received, send Stage2
+    console.info('dji-device: Sending PrepareToLiveStream Stage2');
+    await this.writeMessage(
+      new DjiMessage(
+        preparingToLivestreamTarget,
+        preparingToLivestreamStage2TransactionId,
+        startStopStreamingType,
+        Buffer.from([0x00, 0x01, 0x1c, 0x00]),
+      ),
+    );
+    this.setState(DjiDeviceState.preparingStream2);
+  }
+
+  private async processPreparingStream2(response: DjiMessage): Promise<void> {
+    if (!this.isResponseTo(response, startStopStreamingType)) {
+      return;
+    }
+    console.info(`dji-device: PrepareToLiveStream Stage2 response: payload=${response.payload.toString('hex')}`);
+    if (!this.wifiSsid || !this.wifiPassword) {
+      return;
+    }
+    // Stage2 response received, send WiFi setup
+    console.info(`dji-device: Sending WiFi credentials - SSID: ${this.wifiSsid}, Password: ${this.wifiPassword}`);
     const payload = new DjiSetupWifiMessagePayload(
       this.wifiSsid,
       this.wifiPassword,
     );
-    this.writeMessage(
+    await this.writeMessage(
       new DjiMessage(
         setupWifiTarget,
         setupWifiTransactionId,
@@ -456,10 +624,11 @@ export class DjiDevice {
     this.setState(DjiDeviceState.settingUpWifi);
   }
 
-  private processSettingUpWifi(response: DjiMessage): void {
-    if (response.id !== setupWifiTransactionId || !this.model) {
+  private async processSettingUpWifi(response: DjiMessage): Promise<void> {
+    if (!this.isResponseTo(response, setupWifiType) || !this.model) {
       return;
     }
+    console.info(`dji-device: WiFi setup response: payload=${response.payload.toString('hex')}`);
     switch (+this.model) {
       case DjiDeviceModel.osmoAction3:
         this.sendStartStreaming();
@@ -473,7 +642,7 @@ export class DjiDevice {
           this.imageStabilization,
           false,
         );
-        this.writeMessage(
+        await this.writeMessage(
           new DjiMessage(
             configureTarget,
             configureTransactionId,
@@ -492,7 +661,7 @@ export class DjiDevice {
           this.imageStabilization,
           true,
         );
-        this.writeMessage(
+        await this.writeMessage(
           new DjiMessage(
             configureTarget,
             configureTransactionId,
@@ -512,17 +681,18 @@ export class DjiDevice {
     }
   }
 
-  private processConfiguring(response: DjiMessage): void {
-    if (response.id !== configureTransactionId) {
+  private async processConfiguring(response: DjiMessage): Promise<void> {
+    if (!this.isResponseTo(response, configureType)) {
       return;
     }
     this.sendStartStreaming();
   }
 
-  private sendStartStreaming(): void {
+  private async sendStartStreaming(): Promise<void> {
     if (!this.rtmpUrl || !this.resolution) {
       return;
     }
+    console.info(`dji-device: Sending RTMP config - URL: ${this.rtmpUrl}, Resolution: ${this.resolution}, FPS: ${this.fps}, Bitrate: ${this.bitrate / 1000}kbps`);
     const payload = new DjiStartStreamingMessagePayload(
       this.rtmpUrl,
       this.resolution,
@@ -530,7 +700,7 @@ export class DjiDevice {
       this.bitrate / 1000,
       this.model === DjiDeviceModel.osmoAction5Pro,
     );
-    this.writeMessage(
+    await this.writeMessage(
       new DjiMessage(
         startStreamingTarget,
         startStreamingTransactionId,
@@ -539,34 +709,31 @@ export class DjiDevice {
       ),
     );
 
-    // Patch for OA5P: Send the confirmation payload to actually start the stream.
-    // This is an exact copy of the stop-streaming command, but the last data-bit in the payload is set to 1 instead of 2.
-    // It may probably work fine sending it on all devices, but limiting it to OA5P for now.
-    if (this.model === DjiDeviceModel.osmoAction5Pro) {
-      const confirmStartStreamPayload =
-        new DjiConfirmStartStreamingMessagePayload();
-      this.writeMessage(
-        new DjiMessage(
-          stopStreamingTarget,
-          stopStreamingTransactionId,
-          stopStreamingType,
-          confirmStartStreamPayload.encode(),
-        ),
-      );
-    }
+    // Send the StartStopStreaming confirmation to actually begin the stream
+    // djictl sends this for ALL devices, not just OA5P
+    const confirmStartStreamPayload =
+      new DjiConfirmStartStreamingMessagePayload();
+    await this.writeMessage(
+      new DjiMessage(
+        stopStreamingTarget,
+        confirmStartStreamingTransactionId,
+        stopStreamingType,
+        confirmStartStreamPayload.encode(),
+      ),
+    );
 
     this.setState(DjiDeviceState.startingStream);
   }
 
-  private processStartingStream(response: DjiMessage): void {
-    if (response.id !== startStreamingTransactionId) {
+  private async processStartingStream(response: DjiMessage): Promise<void> {
+    if (!this.isResponseTo(response, startStreamingType) && !this.isResponseTo(response, stopStreamingType)) {
       return;
     }
     this.setState(DjiDeviceState.streaming);
     this.stopStartStreamingTimer();
   }
 
-  private processStreaming(response: DjiMessage): void {
+  private async processStreaming(response: DjiMessage): Promise<void> {
     switch (response.type) {
       case 0x020d00:
         if (response.payload.length >= 21) {
@@ -578,24 +745,38 @@ export class DjiDevice {
     }
   }
 
-  private processStoppingStream(response: DjiMessage): void {
+  private async processStoppingStream(response: DjiMessage): Promise<void> {
     if (response.id !== stopStreamingTransactionId) {
-      return;
+      // return;
     }
     this.reset();
   }
 
-  private writeMessage(message: DjiMessage): void {
-    this.writeValue(message.encode());
+  // Check if a received message is a response to a command type we sent
+  // Device may respond with response flag (0x80) set, or as unsolicited notification (flags=0x02)
+  private isResponseTo(response: DjiMessage, sentType: number): boolean {
+    const sentCmdSet = (sentType >> 8) & 0xff;
+    const sentCmdId = (sentType >> 16) & 0xff;
+    const respFlags = response.type & 0xff;
+    const respCmdSet = (response.type >> 8) & 0xff;
+    const respCmdId = (response.type >> 16) & 0xff;
+    // Match by cmdSet + cmdId with response flag, OR exact cmdSet + cmdId
+    return respCmdSet === sentCmdSet && (respCmdId === sentCmdId || (respFlags & 0x80) !== 0 && respCmdId === sentCmdId);
+  }
+
+  private async writeMessage(message: DjiMessage): Promise<void> {
+    const encoded = message.encode();
+    console.debug(`dji-device: TX [${encoded.toString('hex')}]`);
+    await this.writeValue(encoded);
   }
 
   private async writeValue(value: Buffer): Promise<void> {
-    if (!this.fff3Characteristic) {
-      console.error('dji-device: No characteristic to write to');
+    if (!this.fff5Characteristic) {
+      console.error('dji-device: No fff5 characteristic to write to');
       return;
     }
-    await this.fff3Characteristic
-      .writeAsync(value, false)
+    await this.fff5Characteristic
+      .writeAsync(value, true)
       .then(() => {
         console.debug('dji-device: Write successful');
       })
diff --git a/src/message.ts b/src/message.ts
index 11292fd..371ac20 100644
--- a/src/message.ts
+++ b/src/message.ts
@@ -52,7 +52,7 @@ export class DjiMessage {
     const body = Buffer.concat([
       headerWithCrc,
       Buffer.from([this.target & 0xff, (this.target >> 8) & 0xff]),
-      Buffer.from([this.id & 0xff, (this.id >> 8) & 0xff]),
+      Buffer.from([(this.id >> 8) & 0xff, this.id & 0xff]),
       Buffer.from([
         this.type & 0xff,
         (this.type >> 8) & 0xff,
@@ -94,7 +94,7 @@ export class DjiMessageWithData extends DjiMessage {
       );
     }
     const target = reader.readUint16(true); // LE
-    const id = reader.readUint16(true); // LE
+    const id = reader.readUint16(false); // BE â€” djictl writes MessageID as BE
     const type = reader.readUint24(true); // LE
     const payload = reader.readBytes(reader.bytesRemaining - 2);
     const crc = reader.readUint16(true); // LE
@@ -109,11 +109,8 @@ export class DjiMessageWithData extends DjiMessage {
 }
 
 export class DjiPairMessagePayload {
-  static payload = Buffer.from([
-    0x20, 0x32, 0x38, 0x34, 0x61, 0x65, 0x35, 0x62, 0x38, 0x64, 0x37, 0x36,
-    0x62, 0x33, 0x33, 0x37, 0x35, 0x61, 0x30, 0x34, 0x61, 0x36, 0x34, 0x31,
-    0x37, 0x61, 0x64, 0x37, 0x31, 0x62, 0x65, 0x61, 0x33,
-  ]);
+  // App identifier string â€” matches djictl's default
+  static appIdentifier = '001749319286102';
   pairPinCode: string;
 
   constructor(pairPinCode: string) {
@@ -121,9 +118,9 @@ export class DjiPairMessagePayload {
   }
 
   encode(): Buffer {
-    const payload = DjiPairMessagePayload.payload;
+    const identifierBuffer = djiPackString(DjiPairMessagePayload.appIdentifier);
     const pinCodeBuffer = djiPackString(this.pairPinCode);
-    return Buffer.concat([payload, pinCodeBuffer]);
+    return Buffer.concat([identifierBuffer, pinCodeBuffer]);
   }
 }
 
-- 
2.52.0

